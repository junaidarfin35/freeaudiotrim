<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- SEO Meta Tags -->
  <title>Trim MP3 Online Free - Cut Audio Files Without Uploading</title>
  <meta name="description" content="Trim MP3 and other audio files online for free. Cut audio files directly in your browser without uploading. Fast, private, and secure audio trimmer.">
  <meta name="keywords" content="trim mp3 online, mp3 cutter, cut audio, trim audio online, free mp3 trimmer, audio editor">
  <link rel="canonical" href="https://freeaudiotrim.com/">
  
  <!-- Open Graph -->
  <meta property="og:title" content="Trim MP3 Online Free – Cut Audio Files Without Uploading">
  <meta property="og:description" content="Trim MP3, WAV, M4A and other audio files directly in your browser. No upload, no signup, 100% private.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://freeaudiotrim.com/">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Trim MP3 Online Free – Cut Audio Files Without Uploading">
  <meta name="twitter:description" content="Trim MP3, WAV, M4A and other audio files directly in your browser. No upload, no signup, 100% private.">
  
  <!--lamejs Library-->
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎵</text></svg>">
  
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="/assets/upload.css">
  
  <!-- Schema.org Structured Data -->
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Trim MP3 Online Free",
  "url": "https://freeaudiotrim.com/",
  "applicationCategory": "MultimediaApplication",
  "operatingSystem": "Web Browser",
  "description": "Free online MP3 trimmer that works entirely in your browser. No upload required. Trim, cut and edit audio files securely on your device.",
  "inLanguage": "en",
  "isAccessibleForFree": true,
  "softwareVersion": "1.0",
  "keywords": [
    "trim mp3 online",
    "cut mp3",
    "mp3 cutter",
    "audio trimmer",
    "browser audio editor",
    "trim audio without upload"
  ],
  "featureList": [
  "Trim MP3 files",
  "Cut WAV audio",
  "Supports MP3, WAV, M4A and AAC input formats",
  "Export audio as MP3 or WAV",
  "Browser-based processing",
  "No file upload required"
  ],
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "publisher": {
    "@type": "Organization",
    "name": "FreeAudioTrim",
    "url": "https://freeaudiotrim.com/"
  }
}
</script>

  
  <!-- FAQ Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {"@type":"Question","name":"Does trimming reduce audio quality?","acceptedAnswer":{"@type":"Answer","text":"Trimming removes the parts you do not want but keeps the selected section intact. In normal use, the audible quality of that kept section stays the same. Quality only changes when you export with lower settings or switch to a more compressed format."}},
      {"@type":"Question","name":"Is trimming private?","acceptedAnswer":{"@type":"Answer","text":"Yes. This tool processes audio in your browser, so your file is not sent to our servers for editing. When you close the tab, temporary data from the session is cleared by the browser environment."}},
      {"@type":"Question","name":"What’s the maximum file size?","acceptedAnswer":{"@type":"Answer","text":"A practical limit is around 200 MB for smooth editing in most modern devices. Larger files can still open, but response time depends on your RAM and browser performance. If playback feels slow, split the recording into smaller parts first."}},
      {"@type":"Question","name":"Can I trim on mobile?","acceptedAnswer":{"@type":"Answer","text":"Yes, you can trim audio on Android and iOS using current mobile browsers. The controls are designed for touch, including drag handles and timeline preview. For best results, keep other heavy apps closed while exporting."}},
      {"@type":"Question","name":"What formats are supported?","acceptedAnswer":{"@type":"Answer","text":"You can load common audio types such as MP3, WAV, M4A, AAC, OGG, FLAC, and more where browser decoding is available. Export choices include MP3 (compressed) and WAV (lossless). This gives you flexibility for sharing, archiving, or further editing."}},
      {"@type":"Question","name":"Does trimming change bitrate?","acceptedAnswer":{"@type":"Answer","text":"Trimming by itself does not automatically lower bitrate. Bitrate changes only if you choose different export quality or a different codec during download. If you want to preserve the original sound profile, keep export settings close to the source."}}
    ]
  }
  </script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap');

    .font-mono {
      font-family: 'JetBrains Mono', monospace;
    }

    /* FAQ Styles */
    .faq-item {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }
    
    .faq-question {
      font-weight: 600;
      font-size: 1.125rem;
      color: var(--text);
      margin-bottom: 0.75rem;
    }
    
    .faq-answer {
      color: var(--text-secondary);
      line-height: 1.7;
    }

    /* Privacy Badge */
    .privacy-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: #ecfdf5;
      color: #047857;
      padding: 0.5rem 1rem;
      border-radius: 2rem;
      font-size: 0.875rem;
      font-weight: 500;
      margin-top: 1rem;
    }
  </style>
  <link rel="stylesheet" href="/assets/layout.css">
</head>
<body>
  <!-- Header -->
  <header>
  <div class="header-container">
    <a href="/" class="logo">
      🎵 AudioTools
    </a>
    <nav>
  <a href="/trim-mp3-online.html">MP3 Trimmer</a>
  <a href="/convert-mp3-to-wav.html">Convert</a>
  <a href="/normalize-audio-volume.html">Normalize Volume</a>
  <a href="/blog/">Blog</a>
</nav>
  </div>
</header>

  <!-- Main Content -->
  <main class="container">
    <!-- SECTION 1: H1 + SHORT INTRO -->
    <section class="content-section section-intro">
      <h1>
        Trim MP3 Online Free – Cut Audio Files in Your Browser
      </h1>
      <p>Need a quick way to cut songs, podcasts or voice memos? This browser-based audio trimmer online lets you open an MP3 (or WAV, M4A, AAC etc.) and drag endpoints on an interactive waveform to keep just what you need. No uploads, no signup, no software downloads – everything runs locally for privacy, speed and offline use. The tool handles files up to 200 MB, plays back selections instantly and lets you export as MP3 or WAV with adjustable quality. Whether you're creating a ringtone, editing a podcast intro or trimming a lecture recording, the process is fast and intuitive. Works on desktop or mobile; modern browsers like Chrome, Firefox and Safari are supported. You can trim as many files as you like, on any computer. If you only need a short section, select the exact start and end points, preview the result, and download immediately without opening a desktop editor.
      </p>
      <p>Many users search for a free online audio editor that works instantly without installing software. This MP3 trimmer and browser-based audio cutter lets you edit audio online, cut MP3 files, shorten songs, create ringtones, and prepare podcast clips in seconds — all without uploads or accounts.</p>
      <div class="privacy-badge">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
        </svg>
        100% Client-Side Processing
      </div>
    </section>
    <section class="content-section">
  <h2>Quick Answer: How to Trim MP3 Online</h2>
  <p>To trim MP3 online, upload your audio file, drag the start and end markers on the waveform, preview the selected section, and export as MP3 or WAV. The entire process runs in your browser without uploading your file to a server.</p>
</section>

    <!-- SECTION 2: TOOL INTERFACE -->
    <section class="content-section section-surface">
      <div id="audio-tool"></div>
      <p class="tool-shell-note">
        <strong>Your files never leave your device. No uploads. No account required.</strong>
      </p>
    </section>

    <!-- SECTION 3: HOW TO TRIM MP3 ONLINE -->
    <section class="content-section">
      <h2>How to Trim MP3 Online</h2>
      <p>Just three quick actions let you trim mp3 online in minutes using this free mp3 cutter and audio trimmer online:</p>
      <ol>
        <li>Upload your MP3, WAV, M4A, AAC (etc.) file; it’s decoded instantly in-browser.</li>
        <li>Drag the waveform handles or click to set start and end points for the segment you want.</li>
        <li>Preview with play/spacebar, then hit <strong>Export &amp; Download</strong> to save as MP3 or WAV – you can cut mp3 file or cut audio online with zero fuss.</li>
      </ol>
    </section>

    <!-- SECTION 4: WHY USE THIS MP3 CUTTER -->
    <section class="content-section section-surface">
      <h2>Why Use This Online MP3 Cutter?</h2>
      <p>Our in‑browser MP3 cutter gives you instant, private edits without installing anything. Audio is never uploaded – all decoding, playback and export happen locally, so you stay in control of your files. It handles popular formats (MP3, WAV, AAC, M4A, FLAC, OGG and more) and exports trimmed audio as MP3 (compressed) or WAV (lossless).</p>
      <p>The interface works equally well on desktop and mobile devices; drag the waveform handles, preview with the spacebar, and download the result in seconds. It’s easy to trim audio in browser with no account, no waiting, and no extra steps. There are no limits, no ads, and you don’t even need to sign in – just open the page and start trimming.</p>
      <p>You’re editing with a built-in waveform editor that displays audio duration clearly; adjusting trim points changes the output instantly. Because this is client-side audio editing and browser-based processing, there’s no compression unless you choose it – keep bitrate high, avoid re-encoding, or export in a lossless format for maximum quality. File size stays small and the whole operation is secure trimming: nothing ever leaves your device.</p>
    </section>

    <!-- SECTION 4B: Need more than just trimming? -->
    <section class="content-section">
      <h2>Need More Than Just Trimming?</h2>
      <p>
      Need more than just trimming? You can also 
      <a href="/convert-mp3-to-wav.html">convert MP3 to WAV online</a> 
      without uploading your files. Improve sound clarity using our 
      <a href="/normalize-audio-volume.html">audio volume normalizer</a>, 
      combine tracks with the 
      <a href="/merge-audio-files.html">merge audio files tool</a>, 
      or automatically 
      <a href="/remove-silence-from-audio.html">remove silence from audio</a> 
      to clean up recordings. You can even 
      <a href="/extract-audio-from-video.html">extract audio from video</a> 
      directly in your browser.
      </p>
    </section>


    <!-- SECTION 5A: WHY TRIM WITHOUT UPLOADING -->
    <section class="content-section">
      <h2>Why Trim MP3 Without Uploading?</h2>
      <p>Choosing to trim mp3 without uploading means your private recordings stay private. No server, no account, no transfer – you cut mp3 file fragments right in the browser. That makes it a naturally secure option for anyone who needs to edit audio without installing software or trusting a third party. It’s also much faster; you don’t wait for large files to upload before you can begin to edit a clip.</p>
      <p>Local processing helps you cut mp3 without losing quality because your source file stays on your device from start to finish. You can review every selection before export, keep quality settings under your control, and avoid unnecessary transfers when you only need a short segment.</p>
    </section>

    <!-- SECTION 5B: COMMON USE CASES -->
    <section class="content-section section-surface">
      <h2>Common Use Cases for Trimming Audio</h2>
      <ul>
        <li>Emailing or messaging a clip? Cut mp3 without losing quality and keep file size down.</li>
        <li>Making a ringtone? Cut mp3 file to the perfect length with precise duration control.</li>
        <li>Preparing podcast teasers? Use the audio trimmer online to slice out intros or ads quickly.</li>
        <li>Sharing a voice memo? Shorten mp3 file online and send over mobile without re-encoding.</li>
        <li>Editing a lecture or interview? The waveform editor helps you select important sections fast.</li>
        <li>Working on mobile? Trim mp3 on mobile browser while commuting or in a café.</li>
        <li>Need a quick preview? Cut audio online in seconds to check bitrate or compression effects before finalizing.</li>
      </ul>
    </section>

    <!-- SECTION 5C: VISIBLE FAQ -->
    <section class="content-section">
      <h2>Frequently Asked Questions</h2>
      <div class="faq-item"><div class="faq-question">Does trimming reduce audio quality?</div><div class="faq-answer">Trimming removes the parts you do not want but keeps the selected section intact. In normal use, the audible quality of that kept section stays the same. Quality only changes when you export with lower settings or switch to a more compressed format.</div></div>
      <div class="faq-item"><div class="faq-question">Is trimming private?</div><div class="faq-answer">Yes. This tool processes audio in your browser, so your file is not sent to our servers for editing. When you close the tab, temporary data from the session is cleared by the browser environment.</div></div>
      <div class="faq-item"><div class="faq-question">What’s the maximum file size?</div><div class="faq-answer">A practical limit is around 200 MB for smooth editing in most modern devices. Larger files can still open, but response time depends on your RAM and browser performance. If playback feels slow, split the recording into smaller parts first.</div></div>
      <div class="faq-item"><div class="faq-question">Can I trim on mobile?</div><div class="faq-answer">Yes, you can trim audio on Android and iOS using current mobile browsers. The controls are designed for touch, including drag handles and timeline preview. For best results, keep other heavy apps closed while exporting.</div></div>
      <div class="faq-item"><div class="faq-question">What formats are supported?</div><div class="faq-answer">You can load common audio types such as MP3, WAV, M4A, AAC, OGG, FLAC, and more where browser decoding is available. Export choices include MP3 (compressed) and WAV (lossless). This gives you flexibility for sharing, archiving, or further editing.</div></div>
      <div class="faq-item"><div class="faq-question">Does trimming change bitrate?</div><div class="faq-answer">Trimming by itself does not automatically lower bitrate. Bitrate changes only if you choose different export quality or a different codec during download. If you want to preserve the original sound profile, keep export settings close to the source.</div></div>
    </section>

    <!-- SECTION 6: INTERNAL LINKS -->
    <section class="content-section section-surface">
      <h2>More Free Audio Tools</h2>
      <p>Explore our complete suite of browser-based audio editing tools – all free, private, and requiring no installation:</p>
      
      <div class="tool-links-grid">
        <a href="/convert-mp3-to-wav.html" class="tool-link">
          <strong>Convert MP3 to WAV</strong> – Transform compressed MP3 files to lossless WAV format
        </a>
        <a href="/normalize-audio-volume.html" class="tool-link">
          <strong>Normalize Audio Volume</strong> – Balance volume levels across your audio files
        </a>
        <a href="/remove-silence-from-audio.html" class="tool-link">
          <strong>Remove Silence from Audio</strong> – Automatically detect and remove quiet portions
        </a>
        <a href="/merge-audio-files.html" class="tool-link">
          <strong>Merge Audio Files</strong> – Combine multiple audio tracks into one file
        </a>
        <a href="/extract-audio-from-video.html" class="tool-link">
          <strong>Extract Audio from Video</strong> – Pull audio tracks from video files
        </a>
      </div>
    </section>

    <section class="content-section" aria-labelledby="latest-audio-guides">
      <h2 id="latest-audio-guides">Latest Audio Editing Guides</h2>
      <p>Learn how to trim, convert, normalize and edit audio files with our step-by-step tutorials.</p>

      <div class="blog-grid">
        <article class="blog-card">
          <a href="/blog/how-to-trim-mp3-online.html" aria-label="Read How to Trim MP3 Online guide">
            <img
              src="/assets/blog/trim-mp3-online-guide.webp"
              alt="Audio trimming interface guide cover image for trimming MP3 online"
              loading="lazy"
              decoding="async"
              width="280"
              height="180"
            />
            <div class="blog-card-body">
              <h3>How to Trim MP3 Online</h3>
              <p>Step-by-step guide to cutting MP3 files directly in your browser.</p>
              <span class="blog-cta">Read guide</span>
            </div>
          </a>
        </article>

        <article class="blog-card">
          <a href="/blog/extract-audio-from-video-guide.html" aria-label="Read How to Extract Audio from Video guide">
            <img
              src="/assets/blog/extract-audio-from-video-guide.webp"
              alt="Audio waveform extraction guide cover image for extracting audio from video"
              loading="lazy"
              decoding="async"
              width="280"
              height="180"
            />
            <div class="blog-card-body">
              <h3>How to Extract Audio from Video</h3>
              <p>Convert MP4 and MOV files into clean audio tracks.</p>
              <span class="blog-cta">Read guide</span>
            </div>
          </a>
        </article>

        <article class="blog-card">
          <a href="/blog/convert-mp3-to-wav-guide.html" aria-label="Read Convert MP3 to WAV guide">
            <img
              src="/assets/blog/convert-mp3-to-wav-guide.webp"
              alt="MP3 to WAV conversion guide cover image for audio format conversion"
              loading="lazy"
              decoding="async"
              width="280"
              height="180"
            />
            <div class="blog-card-body">
              <h3>Convert MP3 to WAV Guide</h3>
              <p>Understand format differences and when to use each.</p>
              <span class="blog-cta">Read guide</span>
            </div>
          </a>
        </article>
      </div>
    </section>
  
  </main>

  <!-- RELATED TOOLS -->
<section class="content-section related-tools">
  <h2>Related Audio Tools</h2>

  <div class="tools-grid">
    <a href="/convert-mp3-to-wav.html" class="tool-card">
      Convert Trimmed MP3 to WAV
    </a>

    <a href="/normalize-audio-volume.html" class="tool-card">
      Normalize Audio Volume
    </a>

    <a href="/remove-silence-from-audio.html" class="tool-card">
      Remove Silence from Recording
    </a>

    <a href="/merge-audio-files.html" class="tool-card">
      Merge Multiple Audio Clips
    </a>

    <a href="/extract-audio-from-video.html" class="tool-card">
      Extract Audio from Video
    </a>
  </div>
</section>

  <!-- SECTION 7: FOOTER -->
  <footer>
  <div class="footer-container">
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:2rem;">
      <div>
        <div class="footer-title">AudioTools</div>
        <p class="footer-text">Free browser-based audio editing tools. Private, fast, secure.</p>
      </div>
      <div>
        <div class="footer-title">Tools</div>
        <p><a href="/trim-mp3-online.html" class="footer-text">MP3 Trimmer</a></p>
        <p><a href="/convert-mp3-to-wav.html" class="footer-text">Convert MP3</a></p>
        <p><a href="/normalize-audio-volume.html" class="footer-text">Normalize Volume</a></p>
      </div>
      <div>
        <div class="footer-title">Legal</div>
        <p><a href="/privacy-policy.html" class="footer-text">Privacy Policy</a></p>
        <p><a href="/terms-of-service.html" class="footer-text">Terms of Service</a></p>
        <p><a href="/contact.html" class="footer-text">Contact</a></p>
      </div>
    </div>
    <div class="footer-small">
      © 2026 AudioTools. All rights reserved.
    </div>
  </div>
</footer>

  <!-- Audio Trimmer Tool Component -->
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const AudioTrimmerTool = () => {
      const [audioFile, setAudioFile] = useState(null);
      const [audioBuffer, setAudioBuffer] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const [currentTime, setCurrentTime] = useState(0);
      const [duration, setDuration] = useState(0);
      const [trimStart, setTrimStart] = useState(0);
      const [trimEnd, setTrimEnd] = useState(0);
      const [zoom, setZoom] = useState(1);
      const [panOffset, setPanOffset] = useState(0);
      const [exportFormat, setExportFormat] = useState('mp3');
      const [exportQuality, setExportQuality] = useState('192');
      const [isDragging, setIsDragging] = useState({ playhead: false, start: false, end: false, pan: false });
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);

      const audioContextRef = useRef(null);
      const sourceNodeRef = useRef(null);
      const canvasRef = useRef(null);
      const waveformContainerRef = useRef(null);
      const animationFrameRef = useRef(null);
      const startTimeRef = useRef(0);
      const activeTouchIdRef = useRef(null);
      const lastTouchXRef = useRef(0);

      const supportedFormats = [
        'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/x-wav', 'audio/x-ms-wma',
        'audio/ogg', 'audio/m4r', 'audio/3gpp', 'audio/opus', 'audio/m4a',
        'audio/x-m4a', 'audio/aac', 'audio/amr', 'audio/flac', 'audio/x-flac',
        'audio/aiff', 'audio/x-aiff', 'audio/ape', 'audio/x-ape'
      ];

      const exportFormats = [
      { value: 'wav', label: 'WAV (Lossless)' },
      { value: 'mp3', label: 'MP3' }
    ];

      const qualityOptions = [
        { value: '128', label: '128 kbps' },
        { value: '192', label: '192 kbps (Balanced)' },
        { value: '256', label: '256 kbps' },
        { value: '320', label: '320 kbps (High)' }
      ];

      useEffect(() => {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        return () => {
          if (audioContextRef.current) audioContextRef.current.close();
        };
      }, []);

      useEffect(() => {
        const handleKeyPress = (e) => {
          const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
          if (isSpace && audioBuffer) {
            e.preventDefault();
            togglePlayPause();
          }
        };
        // Use capture so we receive the space key even when a control (e.g. the play button) is focused.
        window.addEventListener('keydown', handleKeyPress, true);
        return () => window.removeEventListener('keydown', handleKeyPress, true);
      }, [audioBuffer, isPlaying]);

      const saveToHistory = useCallback((start, end) => {
        const newHistory = history.slice(0, historyIndex + 1);
        newHistory.push({ start, end });
        if (newHistory.length > 5) newHistory.shift();
        else setHistoryIndex(historyIndex + 1);
        setHistory(newHistory);
      }, [history, historyIndex]);

      const handleFileUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        if (file.size > 200 * 1024 * 1024) {
          alert('File size exceeds 200MB limit');
          return;
        }
        const arrayBuffer = await file.arrayBuffer();
        try {
          const decodedBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);
          setAudioFile(file);
          setAudioBuffer(decodedBuffer);
          setDuration(decodedBuffer.duration);
          setTrimStart(0);
          setTrimEnd(decodedBuffer.duration);
          setCurrentTime(0);
          setHistory([{ start: 0, end: decodedBuffer.duration }]);
          setHistoryIndex(0);
          drawWaveform(decodedBuffer);
        } catch (error) {
          alert('Error decoding audio file. Please try a different file.');
        }
      };

      const drawWaveform = useCallback((buffer) => {
        if (!canvasRef.current) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Transparent background
        ctx.clearRect(0, 0, width, height);

        const data = buffer.getChannelData(0);
        const step = Math.ceil((data.length / zoom) / width);
        const amp = (height - 20) / 2; // Leave space for top handles

        const startX = ((trimStart / duration) * width * zoom) - panOffset;
        const endX = ((trimEnd / duration) * width * zoom) - panOffset;

        // Draw unselected (left) waveform in gray
        ctx.fillStyle = '#6b7280';
        for (let i = 0; i < width; i++) {
          if (i >= startX && i <= endX) continue; // Skip selected area
          let min = 1.0, max = -1.0;
          const offset = Math.floor((i + panOffset) * step);
          for (let j = 0; j < step; j++) {
            const datum = data[offset + j] || 0;
            if (datum < min) min = datum;
            if (datum > max) max = datum;
          }
          const barHeight = Math.max(1, (max - min) * amp);
          ctx.fillRect(i, 20 + amp - (max * amp), 1, barHeight);
        }

        // Draw selected waveform in bright blue
        ctx.fillStyle = '#3b82f6';
        for (let i = 0; i < width; i++) {
          if (i < startX || i > endX) continue; // Only selected area
          let min = 1.0, max = -1.0;
          const offset = Math.floor((i + panOffset) * step);
          for (let j = 0; j < step; j++) {
            const datum = data[offset + j] || 0;
            if (datum < min) min = datum;
            if (datum > max) max = datum;
          }
          const barHeight = Math.max(1, (max - min) * amp);
          ctx.fillRect(i, 20 + amp - (max * amp), 1, barHeight);
        }

        // Draw light blue overlay on selected area
        ctx.fillStyle = 'rgba(191, 219, 254, 0.3)';
        const selectedStart = Math.max(0, startX);
        const selectedEnd = Math.min(width, endX);
        if (selectedEnd > selectedStart) {
          ctx.fillRect(selectedStart, 20, selectedEnd - selectedStart, height - 20);
        }

        // Draw left trim marker line (thin blue, from handle down)
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(startX, 18);
        ctx.lineTo(startX, height);
        ctx.stroke();

        // Draw left selector handle at TOP
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.roundRect(startX - 12, 2, 24, 16, 6);
        ctx.fill();
        // Left handle - dark blue circle in center
        ctx.fillStyle = '#1e40af';
        ctx.beginPath();
        ctx.arc(startX, 10, 6, 0, Math.PI * 2);
        ctx.fill();

        // Draw right trim marker line (thin blue, from handle down)
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(endX, 18);
        ctx.lineTo(endX, height);
        ctx.stroke();

        // Draw right selector handle at TOP
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.roundRect(endX - 12, 2, 24, 16, 6);
        ctx.fill();
        // Right handle - dark blue circle in center
        ctx.fillStyle = '#1e40af';
        ctx.beginPath();
        ctx.arc(endX, 10, 6, 0, Math.PI * 2);
        ctx.fill();

        // Draw playhead line only (red, no circle)
        const playheadX = ((currentTime / duration) * width * zoom) - panOffset;
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(playheadX, 20);
        ctx.lineTo(playheadX, height);
        ctx.stroke();
      }, [trimStart, trimEnd, currentTime, duration, zoom, panOffset]);

      useEffect(() => {
        if (audioBuffer) drawWaveform(audioBuffer);
      }, [audioBuffer, trimStart, trimEnd, currentTime, zoom, panOffset, drawWaveform]);

      const togglePlayPause = () => {
        if (!audioBuffer) return;
        if (isPlaying) {
          if (sourceNodeRef.current) {
            try { sourceNodeRef.current.stop(); } catch (e) {}
            sourceNodeRef.current = null;
          }
          setIsPlaying(false);
          setIsLooping(false);
          isLoopingRef.current = false;
          if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
        } else {
          // If user has selected a region, start from trimStart and loop it.
          const hasSelection = (trimEnd - trimStart) > 0.05;
          const startFrom = hasSelection ? trimStart : Math.max(trimStart, Math.min(currentTime, trimEnd));
          setCurrentTime(startFrom);
          setIsLooping(true);
          isLoopingRef.current = true;
          playAudio(startFrom);
        }
      };

      const playAudio = (startFrom = 0) => {
        if (sourceNodeRef.current) {
          try { sourceNodeRef.current.stop(); } catch (e) {}
        }
        const source = audioContextRef.current.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContextRef.current.destination);
        const offset = Math.max(trimStart, Math.min(startFrom, trimEnd));
        const dur = trimEnd - offset;
        // Record the audio context time when playback started; currentTime = offset + (audioContextTime - startTime)
        startTimeRef.current = audioContextRef.current.currentTime;
        source.start(0, offset, dur);
        sourceNodeRef.current = source;
        setIsPlaying(true);

        const updateTime = () => {
          const elapsed = audioContextRef.current.currentTime - startTimeRef.current;
          setCurrentTime(offset + elapsed);
          if (elapsed >= dur) {
            if (isLoopingRef.current) {
              // Loop: restart from beginning of selection
              playAudio(trimStart);
            } else {
              setIsPlaying(false);
              setCurrentTime(trimStart);
              if (sourceNodeRef.current) {
                try { sourceNodeRef.current.stop(); } catch (e) {}
                sourceNodeRef.current = null;
              }
            }
          } else {
            animationFrameRef.current = requestAnimationFrame(updateTime);
          }
        };
        updateTime();
        source.onended = () => {
          if (isPlaying && isLoopingRef.current) {
            playAudio(trimStart);
          } else if (isPlaying) {
            setIsPlaying(false);
            setCurrentTime(trimStart);
          }
        };
      };

      const skipBackward = () => {
        const newTime = Math.max(trimStart, currentTime - 2);
        setCurrentTime(newTime);
        if (isPlaying) playAudio(newTime);
      };

      const skipForward = () => {
        const newTime = Math.min(trimEnd, currentTime + 2);
        setCurrentTime(newTime);
        if (isPlaying) playAudio(newTime);
      };

      const zoomIn = () => setZoom(Math.min(zoom * 1.5, 10));
      const zoomOut = () => setZoom(Math.max(zoom / 1.5, 1));

      const undo = () => {
        if (historyIndex > 0) {
          const newIndex = historyIndex - 1;
          setHistoryIndex(newIndex);
          const state = history[newIndex];
          setTrimStart(state.start);
          setTrimEnd(state.end);
        }
      };

      const redo = () => {
        if (historyIndex < history.length - 1) {
          const newIndex = historyIndex + 1;
          setHistoryIndex(newIndex);
          const state = history[newIndex];
          setTrimStart(state.start);
          setTrimEnd(state.end);
        }
      };

      const getWaveformPointerData = (clientX, clientY) => {
        if (!waveformContainerRef.current) return null;
        const rect = waveformContainerRef.current.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const width = rect.width;
        const clickTime = ((x + panOffset) / (width * zoom)) * duration;
        const startX = ((trimStart / duration) * width * zoom) - panOffset;
        const endX = ((trimEnd / duration) * width * zoom) - panOffset;
        const playheadX = ((currentTime / duration) * width * zoom) - panOffset;

        return { x, y, clickTime, startX, endX, playheadX };
      };

      const handleWaveformPointerDown = (clientX, clientY, options = {}) => {
        if (!audioBuffer || !waveformContainerRef.current) return false;

        const pointer = getWaveformPointerData(clientX, clientY);
        if (!pointer) return false;

        const { isTouch = false, shiftKey = false } = options;
        const playheadHitX = isTouch ? 36 : 15;
        const handleHitX   = isTouch ? 42 : 15;
        const handleHitY   = isTouch ? 60 : 25;
        const { x, y, clickTime, startX, endX, playheadX } = pointer;

        if (Math.abs(x - playheadX) < playheadHitX) {
          setIsDragging({ playhead: true, start: false, end: false, pan: false });
          const newTime = Math.max(trimStart, Math.min(clickTime, trimEnd));
          setCurrentTime(newTime);
          return true;
        }

        if (Math.abs(x - startX) < handleHitX && y < handleHitY) {
          setIsDragging({ playhead: false, start: true, end: false, pan: false });
          return true;
        }

        if (Math.abs(x - endX) < handleHitX && y < handleHitY) {
          setIsDragging({ playhead: false, start: false, end: true, pan: false });
          return true;
        }

        if (!isTouch && shiftKey) {
          setIsDragging({ playhead: false, start: false, end: false, pan: true });
          return true;
        }

        const newTime = Math.max(trimStart, Math.min(clickTime, trimEnd));
        setCurrentTime(newTime);
        return false;
      };

      const handleWaveformMouseDown = (e) => {
        handleWaveformPointerDown(e.clientX, e.clientY, { isTouch: false, shiftKey: e.shiftKey });
      };

      const [hoveredElement, setHoveredElement] = useState(null);
      const [isLooping, setIsLooping] = useState(false);
      const isLoopingRef = useRef(false);

      const handleWaveformPointerMove = (clientX, clientY, options = {}) => {
        if (!audioBuffer || !waveformContainerRef.current) return;
        const pointer = getWaveformPointerData(clientX, clientY);
        if (!pointer) return;

        const { x, y, clickTime, startX, endX, playheadX } = pointer;
        const { updateHover = false, movementX = 0 } = options;

        // Update cursor based on what's being hovered
        if (updateHover && Math.abs(x - playheadX) < 15) {
          waveformContainerRef.current.style.cursor = 'grab';
          setHoveredElement('playhead');
        } else if (updateHover && (Math.abs(x - startX) < 15 || Math.abs(x - endX) < 15) && y < 25) {
          waveformContainerRef.current.style.cursor = 'grab';
          setHoveredElement(Math.abs(x - startX) < 15 ? 'start' : 'end');
        } else if (updateHover) {
          waveformContainerRef.current.style.cursor = 'crosshair';
          setHoveredElement(null);
        }

        if (isDragging.playhead) {
          const newTime = Math.max(trimStart, Math.min(clickTime, trimEnd));
          setCurrentTime(newTime);
          if (isPlaying) playAudio(newTime);
        } else if (isDragging.start) {
          setTrimStart(Math.max(0, Math.min(clickTime, trimEnd - 0.1)));
        } else if (isDragging.end) {
          setTrimEnd(Math.max(trimStart + 0.1, Math.min(clickTime, duration)));
        } else if (isDragging.pan) {
          setPanOffset(Math.max(0, panOffset - movementX));
        }
      };

      const handleWaveformMouseMove = (e) => {
        handleWaveformPointerMove(e.clientX, e.clientY, { updateHover: true, movementX: e.movementX });
      };

      const handleWaveformMouseUp = () => {
        if (isDragging.start || isDragging.end) {
          saveToHistory(trimStart, trimEnd);
        }
        setIsDragging({ playhead: false, start: false, end: false, pan: false });
      };

      const findActiveTouch = (touchList) => {
        if (activeTouchIdRef.current === null) return null;
        for (let i = 0; i < touchList.length; i++) {
          if (touchList[i].identifier === activeTouchIdRef.current) {
            return touchList[i];
          }
        }
        return null;
      };

      const handleWaveformTouchStart = (e) => {
        if (!audioBuffer || e.changedTouches.length === 0) return;
        const touch = e.changedTouches[0];
        activeTouchIdRef.current = touch.identifier;
        lastTouchXRef.current = touch.clientX;
        const startedDrag = handleWaveformPointerDown(touch.clientX, touch.clientY, { isTouch: true });
        if (startedDrag) {
          e.preventDefault();
        }
      };

      const handleWaveformTouchMove = (e) => {
        const touch = findActiveTouch(e.touches);
        if (!touch) return;

        const movementX = touch.clientX - lastTouchXRef.current;
        lastTouchXRef.current = touch.clientX;

        handleWaveformPointerMove(touch.clientX, touch.clientY, { updateHover: false, movementX });

        if (isDragging.playhead || isDragging.start || isDragging.end || isDragging.pan) {
          e.preventDefault();
        }
      };

      const handleWaveformTouchEnd = (e) => {
        const touch = findActiveTouch(e.changedTouches);
        if (!touch) return;
        if (isDragging.playhead || isDragging.start || isDragging.end || isDragging.pan) {
          e.preventDefault();
        }
        activeTouchIdRef.current = null;
        handleWaveformMouseUp();
      };

  const exportAudio = async () => {
  if (!audioBuffer) return;

  const offlineContext = new OfflineAudioContext(
    audioBuffer.numberOfChannels,
    Math.ceil((trimEnd - trimStart) * audioBuffer.sampleRate),
    audioBuffer.sampleRate
  );

  const source = offlineContext.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(offlineContext.destination);
  source.start(0, trimStart, trimEnd - trimStart);

  const renderedBuffer = await offlineContext.startRendering();

  // ===== WAV EXPORT =====
  if (exportFormat === "wav") {
    const wav = audioBufferToWav(renderedBuffer);
    const blob = new Blob([wav], { type: "audio/wav" });
    downloadBlob(blob, "wav");
  }

  // ===== MP3 EXPORT =====
  else if (exportFormat === "mp3") {
    const mp3Blob = encodeMP3(renderedBuffer, exportQuality);
    downloadBlob(mp3Blob, "mp3");
  }
};
function downloadBlob(blob, extension) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `trimmed_audio.${extension}`;
  a.click();
  URL.revokeObjectURL(url);
}
function encodeMP3(audioBuffer, bitrate) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, parseInt(bitrate));

  const blockSize = 1152;
  const left = audioBuffer.getChannelData(0);
  const right = numChannels > 1 ? audioBuffer.getChannelData(1) : left;

  let mp3Data = [];

  for (let i = 0; i < left.length; i += blockSize) {
    const leftChunk = left.subarray(i, i + blockSize);
    const rightChunk = right.subarray(i, i + blockSize);

    const left16 = convertFloatToInt16(leftChunk);
    const right16 = convertFloatToInt16(rightChunk);

    const mp3buf = mp3encoder.encodeBuffer(left16, right16);
    if (mp3buf.length > 0) {
      mp3Data.push(new Uint8Array(mp3buf));
    }
  }

  const endBuf = mp3encoder.flush();
  if (endBuf.length > 0) {
    mp3Data.push(new Uint8Array(endBuf));
  }

  return new Blob(mp3Data, { type: "audio/mp3" });
}


function convertFloatToInt16(buffer) {
  let l = buffer.length;
  let buf = new Int16Array(l);
  while (l--) {
    buf[l] = Math.max(-1, Math.min(1, buffer[l])) * 0x7fff;
  }
  return buf;
}
      const audioBufferToWav = (buffer) => {
        const length = buffer.length * buffer.numberOfChannels * 2 + 44;
        const arrayBuffer = new ArrayBuffer(length);
        const view = new DataView(arrayBuffer);
        const channels = [];
        let offset = 0;
        let pos = 0;

        const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; };
        const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; };

        setUint32(0x46464952);
        setUint32(length - 8);
        setUint32(0x45564157);
        setUint32(0x20746d66);
        setUint32(16);
        setUint16(1);
        setUint16(buffer.numberOfChannels);
        setUint32(buffer.sampleRate);
        setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
        setUint16(buffer.numberOfChannels * 2);
        setUint16(16);
        setUint32(0x61746164);
        setUint32(length - pos - 4);

        for (let i = 0; i < buffer.numberOfChannels; i++) {
          channels.push(buffer.getChannelData(i));
        }

        while (pos < length) {
          for (let i = 0; i < buffer.numberOfChannels; i++) {
            let sample = Math.max(-1, Math.min(1, channels[i][offset]));
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            view.setInt16(pos, sample, true);
            pos += 2;
          }
          offset++;
        }
        return arrayBuffer;
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 100);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
      };

      return (
        <div style={{ maxWidth: '1000px', margin: '0 auto' }}>
          {!audioFile && (
            <div style={{ border: '2px dashed var(--border)', borderRadius: '1rem', padding: '3rem 2rem', textAlign: 'center', background: 'white' }}>
              <input type="file" accept={supportedFormats.join(',')} onChange={handleFileUpload} style={{ display: 'none' }} id="fileInput" />
              <div className="upload-box">
                <div className="upload-content">
                  <div className="upload-icon">☁️</div>
                  <h2>Upload Audio File</h2>
                  <p>MP3, WAV, AAC, M4A, FLAC, OGG and more</p>
                </div>
              </div>
            </div>
          )}

          {audioFile && audioBuffer && (
            <div style={{ display: 'grid', gap: '1.5rem' }}>
              <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1rem', border: '1px solid var(--border)' }}>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                  <div>
                    <h3 style={{ fontWeight: '600', fontSize: '1rem', marginBottom: '0.25rem' }}>{audioFile.name}</h3>
                    <p style={{ fontSize: '0.875rem', color: 'var(--text-secondary)', margin: 0 }}>
                      {(audioFile.size / 1024 / 1024).toFixed(2)} MB • {formatTime(duration)}
                    </p>
                  </div>
                  <button onClick={() => { setAudioFile(null); setAudioBuffer(null); setIsPlaying(false); setCurrentTime(0); }} style={{ background: 'none', border: 'none', color: 'var(--text-secondary)', cursor: 'pointer', padding: '0.5rem' }}>
                    <svg style={{ width: '20px', height: '20px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>
              </div>

              <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1.5rem', border: '1px solid var(--border)' }}>
                <div ref={waveformContainerRef} style={{ position: 'relative', background: 'var(--surface)', borderRadius: '0.5rem', overflow: 'hidden', cursor: 'crosshair', height: '180px', touchAction: 'none' }} onMouseDown={handleWaveformMouseDown} onMouseMove={handleWaveformMouseMove} onMouseUp={handleWaveformMouseUp} onMouseLeave={handleWaveformMouseUp} onTouchStart={handleWaveformTouchStart} onTouchMove={handleWaveformTouchMove} onTouchEnd={handleWaveformTouchEnd} onTouchCancel={handleWaveformTouchEnd}>
                  <canvas ref={canvasRef} width={800} height={180} style={{ width: '100%', height: '100%' }} />
                </div>

                <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginTop: '1rem', flexWrap: 'wrap' }}>
                  <button onClick={zoomOut} style={{ padding: '0.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '0.5rem', cursor: 'pointer', display: 'flex', alignItems: 'center' }} title="Zoom Out">
                    <svg style={{ width: '18px', height: '18px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/><line x1="8" x2="14" y1="11" y2="11"/>
                    </svg>
                  </button>
                  <button onClick={zoomIn} style={{ padding: '0.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '0.5rem', cursor: 'pointer', display: 'flex', alignItems: 'center' }} title="Zoom In">
                    <svg style={{ width: '18px', height: '18px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/>
                    </svg>
                  </button>
                  <span style={{ fontSize: '0.875rem', color: 'var(--text-secondary)' }}>Zoom: {zoom.toFixed(1)}x</span>
                  <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>Shift + Drag to pan</span>
                  <div style={{ flex: 1 }} />
                  <button onClick={undo} disabled={historyIndex <= 0} style={{ padding: '0.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '0.5rem', cursor: historyIndex <= 0 ? 'not-allowed' : 'pointer', opacity: historyIndex <= 0 ? 0.5 : 1, display: 'flex', alignItems: 'center' }} title="Undo">
                    <svg style={{ width: '18px', height: '18px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                    </svg>
                  </button>
                  <button onClick={redo} disabled={historyIndex >= history.length - 1} style={{ padding: '0.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '0.5rem', cursor: historyIndex >= history.length - 1 ? 'not-allowed' : 'pointer', opacity: historyIndex >= history.length - 1 ? 0.5 : 1, display: 'flex', alignItems: 'center' }} title="Redo">
                    <svg style={{ width: '18px', height: '18px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/>
                    </svg>
                  </button>
                </div>
              </div>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))', gap: '1rem' }}>
                <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1rem', border: '1px solid var(--border)' }}>
                  <p style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Start Time</p>
                  <p className="font-mono" style={{ fontSize: '1.25rem', color: '#f59e0b', fontWeight: '600', margin: 0 }}>{formatTime(trimStart)}</p>
                </div>
                <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1rem', border: '1px solid var(--border)' }}>
                  <p style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>End Time</p>
                  <p className="font-mono" style={{ fontSize: '1.25rem', color: '#ef4444', fontWeight: '600', margin: 0 }}>{formatTime(trimEnd)}</p>
                </div>
                <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1rem', border: '1px solid var(--border)' }}>
                  <p style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Selection</p>
                  <p className="font-mono" style={{ fontSize: '1.25rem', color: '#10b981', fontWeight: '600', margin: 0 }}>{formatTime(trimEnd - trimStart)}</p>
                </div>
                <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1rem', border: '1px solid var(--border)' }}>
                  <p style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Total</p>
                  <p className="font-mono" style={{ fontSize: '1.25rem', fontWeight: '600', margin: 0 }}>{formatTime(duration)}</p>
                </div>
              </div>

              <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1.5rem', border: '1px solid var(--border)' }}>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '1rem' }}>
                  <button onClick={skipBackward} style={{ padding: '0.75rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '50%', cursor: 'pointer', display: 'flex', alignItems: 'center', transition: 'all 0.2s' }} title="Rewind 2s">
                    <svg style={{ width: '24px', height: '24px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <polygon points="19 20 9 12 19 4 19 20"/><line x1="5" x2="5" y1="19" y2="5"/>
                    </svg>
                  </button>
                  <button onClick={togglePlayPause} style={{ padding: '1.25rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)', color: 'white', border: 'none', borderRadius: '50%', cursor: 'pointer', display: 'flex', alignItems: 'center', boxShadow: '0 4px 12px rgba(37, 99, 235, 0.3)', transition: 'all 0.2s' }}>
                    {isPlaying ? (
                      <svg style={{ width: '32px', height: '32px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/>
                      </svg>
                    ) : (
                      <svg style={{ width: '32px', height: '32px', marginLeft: '4px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                      </svg>
                    )}
                  </button>
                  <button onClick={skipForward} style={{ padding: '0.75rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '50%', cursor: 'pointer', display: 'flex', alignItems: 'center', transition: 'all 0.2s' }} title="Forward 2s">
                    <svg style={{ width: '24px', height: '24px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19"/>
                    </svg>
                  </button>
                </div>
                <p style={{ textAlign: 'center', fontSize: '0.875rem', color: 'var(--text-secondary)', marginTop: '1rem', marginBottom: 0 }}>
                  Press <kbd style={{ padding: '0.25rem 0.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '0.25rem', fontFamily: 'JetBrains Mono, monospace', fontSize: '0.75rem' }}>SPACE</kbd> to play/pause
                </p>
              </div>

              <div style={{ background: 'white', borderRadius: '0.75rem', padding: '1.5rem', border: '1px solid var(--border)' }}>
                <h3 style={{ fontSize: '1.125rem', fontWeight: '600', marginBottom: '1rem' }}>Export Settings</h3>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem', marginBottom: '1.5rem' }}>
                  <div>
                    <label style={{ display: 'block', fontSize: '0.875rem', color: 'var(--text-secondary)', marginBottom: '0.5rem', fontWeight: '500' }}>Format</label>
                    <select value={exportFormat} onChange={(e) => setExportFormat(e.target.value)} style={{ width: '100%', padding: '0.75rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '0.5rem', fontSize: '0.9375rem' }}>
                      {exportFormats.map(fmt => <option key={fmt.value} value={fmt.value}>{fmt.label}</option>)}
                    </select>
                  </div>
                  {exportFormat === "mp3" && (
              <div>
                <label style={{ display: 'block', fontSize: '0.875rem', color: 'var(--text-secondary)', marginBottom: '0.5rem', fontWeight: '500' }}>
                 Quality
               </label>
    <select
      value={exportQuality}
      onChange={(e) => setExportQuality(e.target.value)}
      style={{
        width: '100%',
        padding: '0.75rem',
        background: 'var(--surface)',
        border: '1px solid var(--border)',
        borderRadius: '0.5rem',
        fontSize: '0.9375rem'
      }}
    >
      {qualityOptions.map(qual => (
        <option key={qual.value} value={qual.value}>
          {qual.label}
        </option>
      ))}
    </select>
  </div>
)}

                </div>
                <button onClick={exportAudio} style={{ width: '100%', padding: '1rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)', color: 'white', border: 'none', borderRadius: '0.5rem', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.5rem', transition: 'all 0.2s' }}>
                  <svg style={{ width: '20px', height: '20px' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/>
                  </svg>
                  Export & Download
                </button>
              </div>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('audio-tool'));
    root.render(<AudioTrimmerTool />);
  </script>
  <script src="/assets/upload.js"></script>
</body>
</html>




